# Knative + CoCo + Attestation

In this demo, we set up CoCo to attest the guest VM that is bootstrapped.
In order to run a functional attested system we need a service that, given
a launch digest, returns a secret (i.e. a relying party). We use CoCo's
[simple KBS](https://github.com/confidential-containers/simple-kbs).

For demonstration purposes, the simple KBS runs as a process in the same
node (outside Knative, and Kubernetes for that same reason). To start it,
just run:

```bash
inv kbs.start
```

Depending on what features do you want to measure/attest, browse through the
following subsections (in increasing order of security):
* [Firmware Digest](#firmware-digest) - Attest that the VM runs in an SEV node,
with the right firmware, kernel, initrd, and Kata Agent configuration.

After that, you may jump to [running the application](#run-the-application).

## Firmware Digest

Before running the application, we need to generate the expected launch digest
for our confidential VM. This launch digest will be generated by reading some
of the fields in the Kata config file, so we must update it before generating
the digest.

First, we need to set `guest_pre_attestation` so that the Kata Shim opens a
secure channel between the PSP and the KBS at boot time. We will later use this
hannel to validate firmware and software measurements from inside the guest:

```bash
inv coco.guest-attestation --mode on
```

note that this method also sets the right KBS URI, as the default one
(`localhost`) is not reachable from inside the guest.

Now, we must also enable signature verification. Signature verification is the
only method available in `v0.7.0` to check the launch digest against a user-
provided digest:

```bash
inv coco.signature-verification --mode on
```

In order to validate the launch digest, we need to pre-provision the launch
digest. To do so you may run:

```bash
inv kbs.provision-launch-digest --signature-policy none
```

this method will generate launch digests from the data in the Kata configuration
files (i.e. `/opt/confidential-containers/share/defaults/kata-containers/configuration-*.toml`
if installed by the operator), and include them in the KBS.

## Signed Container Images

If we enable signature verification, we then need to sign our container image
too. As [recommended](https://github.com/sigstore/cosign#sign-a-container-and-store-the-signature-in-the-registry),
we sign images based on their digest:

```bash
inv cosign.sign-container-image "docker.io/csegarragonz/coco-helloworld-py@sha256:af0fec55e9aed9a259e8da9dcaa28ab3fc1277dc8db4b8883265f98272cef11d"
inv cosign.sign-container-image "gcr.io/knative-releases/knative.dev/serving/cmd/queue@sha256:987f53e3ead58627e3022c8ccbb199ed71b965f10c59485bab8015ecf18b44af"
```

## Encrypted Container Images

## Run the application

Once the KBS has been populated with the right measurements and secrets, we can
deploy the workload just like with the `Hello world! (Knative)` app:

```bash
kubectl apply -f ./apps/helloworld-knative
```
